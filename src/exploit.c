/* EXPLOIT.c
 *   by DukeD1rtfarm3r
 *
 * Created:
 *   10/09/2020, 15:27:09
 * Last edited:
 *   10/09/2020, 17:10:37
 * Auto updated?
 *   Yes
 *
 * Description:
 *   This file is the entry point for the exploit of assignment 2 of the
 *   course Computer and Network Security.
 * 
 *   The Mitnick-Attack works in the following way by exploiting a trust
 *   relationship between a terminal and a server. First, we will DoS the
 *   server so it will not bother subsequent communication between us and the
 *   terminal. Then, we will send many TCP-handshakes with the xterminal to
 *   (hopefully) determine a fault in its TCP sequence number generation, which
 *   we can use to predict those. Finally, we inject a backdoor in the
 *   xterminal using said broken sequence number prediction.
 * 
 *   Note that this program supports three operating modes:
 *     - Smash 'n' grab (--smashgrab): Runs the exploit, steals the secret.txt
 *       and cleans up again (including removal of said backdoor)
 *     - Exploit (--exploit): Only exploit the server, but do not cleanup yet
 *     - Cleanup (--cleanup): Cleanup an exploited server.
 * 
**/

typedef unsigned int uint;
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <libnet.h>


/***** CONSTANTS *****/
/* The maximum number of characters (including '\0') in an IPv4-address string. */
#define IPV4_ADDR_LENGTH 16
/* The maximum number of characters (including '\0') in an interface string. */
#define MAX_INTERFACE_SIZE 8
/* The default ip-address of the xterminal. */
#define DEFAULT_XTERM_ADDR "172.16.54.4"
/* The default ip-address of the server. */
#define DEFAULT_SERVER_ADDR "172.16.54.3"
/* The default interface. */
#define DEFAULT_INTERFACE "eth0"



/***** TOOLS ****/
/* Returns 1 if given two strings are equal, or 0 otherwise. */
int streq(char* s1, char* s2) {
    for (int i = 0; ; i++) {
        if (s1[i] != s2[i]) { return 0; }
        else if (s1[i] == '\0') { return 1; }
    }
}
/* Returns 1 if given string is a valid ip-address, or 0 otherwise. */
int is_valid_ip(char* ip_addr) {
    int ip[4];
    int offset;
    if (sscanf(ip_addr, "%u.%u.%u.%u %n", ip, ip + 1, ip + 2, ip + 3, &offset) < 4) {
        return 0;
    }
    // Check if not any other characters
    if (strlen(ip_addr) != (size_t) offset) { return 0; }
    // Check if within range
    for (int i = 0; i < 4; i++) {
        if (ip[i] > 255) { return 0; }
    }
    return 1;
}



/***** HELPER FUNCTIONS *****/
/* Prints a neat help message. */
void print_help(char* executable) {
    printf("Usage: %s -x XTERM_IP -s SERVER_IP -i INTERFACE\n", executable);
}

/* Parses the commandline arguments and does some other initializations. Specifically, extracts:
 *   - The xterminal's ip
 *   - The server's ip
 * Returns 0 on success, or an error code if something went wrong.
 */
int parse_cli(char* xterm_ip, char* server_ip, char* interface, int argc, char** argv) {
    for (int i = 1; i < argc; i++) {
        char* arg = argv[i];
        if (arg[0] == '-') {
            // Either single-label or multi-label
            if ((arg[1] == 'h' && arg[2] == '\0') || streq(arg + 1, "-help")) {
                // Print the help message, then quit
                print_help(argv[0]);
                return -2;
            } else if ((arg[1] == 'x' && arg[2] == '\0') || streq(arg + 1, "-xterm")) {
                // xterm ip, so parse the next argument as an ip
                if (i == argc - 1) {
                    fprintf(stderr, "[ERROR] Missing value for '%s'.\n", arg);
                }
                if (!is_valid_ip(argv[i + 1])) {
                    fprintf(stderr, "[ERROR] Invalid xterminal ip-address '%s'.\n", argv[i + 1]);
                    return -1;
                }
                strcpy(xterm_ip, argv[i + 1]);
            } else if ((arg[1] == 's' && arg[2] == '\0') || streq(arg + 1, "-server")) {
                // xterm ip, so parse the next argument as an ip
                if (i == argc - 1) {
                    fprintf(stderr, "[ERROR] Missing value for '%s'.\n", arg);
                }
                if (!is_valid_ip(argv[i + 1])) {
                    fprintf(stderr, "[ERROR] Invalid server ip-address '%s'.\n", argv[i + 1]);
                    return -1;
                }
                strcpy(server_ip, argv[i + 1]);
            } else if ((arg[1] == 'i' && arg[2] == '\0') || streq(arg + 1, "-interface")) {
                // xterm ip, so parse the next argument as an ip
                if (i == argc - 1) {
                    fprintf(stderr, "[ERROR] Missing value for '%s'.\n", arg);
                }
                if (strlen(argv[i + 1]) >= MAX_INTERFACE_SIZE) {
                    fprintf(stderr, "[ERROR] Too long name for interface '%s'.\n", argv[i + 1]);
                }
                strcpy(interface, argv[i + 1]);
            }
        }
    }

    // Done
    return 0;

}



/***** ENTRY POINT *****/
int main(int argc, char** argv) {
    /* Parse the command line args. */
    // Declare the space to hold the values
    char xterm_ip[IPV4_ADDR_LENGTH];
    char server_ip[IPV4_ADDR_LENGTH];
    char interface[MAX_INTERFACE_SIZE];

    // Fill those with the default values
    strcpy(xterm_ip, DEFAULT_XTERM_ADDR);
    strcpy(server_ip, DEFAULT_SERVER_ADDR);
    strcpy(interface, DEFAULT_INTERFACE);

    // Parse the CLI
    int result = parse_cli(xterm_ip, server_ip, interface, argc, argv);
    if (result == -2) { return EXIT_SUCCESS; }
    else if (result != 0) { return result; }

    /* Print a neat header message. */
    printf("\n*** KEVIN MITNICK SIMULATOR 2020 ***\n\n");

    // Print the options used
    printf("Using options:\n");
    printf(" - Xterminal IP : %s\n", xterm_ip);
    printf(" - Server IP    : %s\n", server_ip);
    printf("\n");
    fflush(stdout);

    /* Prepare exploitation by opening an interface. */
    printf("Initializing libnet on interface '%s'...", interface);
    // Initialize the libnet context & error message buffer
    libnet_t* l;
    char libnet_error[LIBNET_ERRBUF_SIZE];

    // Open a handle to the libnet thing
    l = libnet_init(LIBNET_LINK, interface, libnet_error);
    if (l == NULL) {
        fprintf(stderr, "[ERROR] Could not initialize libnet: %s.\n\n", libnet_error);
        return EXIT_FAILURE;
    }

    // Exit
    libnet_destroy(l);
    printf("\nDone.\n\n");

    return EXIT_SUCCESS;
    
}
